<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js P2P Minecraft Clone</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #instructions, #peer-info {
      position: absolute; width: 100%; text-align: center;
      color: #ffffff; font-family: Arial; user-select: none;
    }
    #instructions { top: 50%; font-size: 24px; }
    #peer-info { top: 10px; font-size: 14px; }
    #connect { position: absolute; top: 40px; left: 50%; transform: translateX(-50%); }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
      "three/examples/jsm/controls/PointerLockControls.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/PointerLockControls.js"
    }
  }
  </script>
  <script src="https://unpkg.com/peerjs@1.3.2/dist/peerjs.min.js"></script>
</head>
<body>
  <div id="instructions">Click to play</div>
  <div id="peer-info"></div>
  <input id="connect" placeholder="Enter peer ID and press Enter" />

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
    import SimplexNoise from 'https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.js';

    // P2P Setup via PeerJS
    const peer = new Peer();
    const connections = {};
    const playerNames = {};
    peer.on('open', id => document.getElementById('peer-info').textContent = `Your Peer ID: ${id}`);
    document.getElementById('connect').addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const remote = e.target.value.trim();
        if (remote && !connections[remote]) setupConnection(peer.connect(remote));
        e.target.value = '';
      }
    });
    peer.on('connection', setupConnection);
    function setupConnection(conn) {
      connections[conn.peer] = conn;
      conn.on('data', data => {
        if (data.type === 'join') playerNames[conn.peer] = data.name;
        if (data.type === 'pos') {
          const s = getOrCreateSprite(conn.peer);
          s.position.set(data.x, data.y, data.z);
        }
      });
      conn.on('open', () => conn.send({ type: 'join', name: playerName }));
    }
    function broadcast(d) { Object.values(connections).forEach(c => c.send(d)); }

    // Name
    const adjectives=['Brave','Cunning','Swift','Ancient','Mighty','Silent','Fierce','Gentle'];
    const nouns=['Lion','Wolf','Eagle','Dragon','Fox','Tiger','Bear','Hawk'];
    function rand(a){return a[Math.floor(Math.random()*a.length)];}
    const playerName = rand(adjectives)+rand(nouns)+Math.floor(Math.random()*1000);

    // Three.js init
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new PointerLockControls(camera, document.body);
    const instr = document.getElementById('instructions');
    instr.addEventListener('click', ()=>controls.lock());
    controls.addEventListener('lock', ()=>instr.style.display='none');
    controls.addEventListener('unlock', ()=>instr.style.display='');
    scene.add(new THREE.AmbientLight(0xffffff,0.6));
    const sun = new THREE.DirectionalLight(0xffffff,0.6);
    sun.position.set(100,100,50);
    scene.add(sun);

    // Materials
    const grassMats = [
      new THREE.MeshLambertMaterial({color:0x964B00}), // right
      new THREE.MeshLambertMaterial({color:0x964B00}), // left
      new THREE.MeshLambertMaterial({color:0x00ff00}), // top
      new THREE.MeshLambertMaterial({color:0x964B00}), // bottom
      new THREE.MeshLambertMaterial({color:0x964B00}), // front
      new THREE.MeshLambertMaterial({color:0x964B00})  // back
    ];
    const dirtMats = Array(6).fill().map(()=>new THREE.MeshLambertMaterial({color:0x964B00}));
    const stoneMats = Array(6).fill().map(()=>new THREE.MeshLambertMaterial({color:0x888888}));

    // Procedural terrain with noise
    const noise = new SimplexNoise();
    const noiseScale = 0.1;
    const W=32, D=32, H=16;
    const blocks = {}, geoms = {};
    const key=(x,y,z)=>`${x},${y},${z}`;
    function addBlock(x,y,z,mats){
      const gk='1x1x1';
      if(!geoms[gk]) geoms[gk] = new THREE.BoxBufferGeometry(1,1,1);
      const m = new THREE.Mesh(geoms[gk], mats || dirtMats);
      m.position.set(x+0.5,y+0.5,z+0.5);
      scene.add(m);
      blocks[key(x,y,z)] = m;
    }
    // Generate blocks
    for(let x=-W/2;x<W/2;x++){
      for(let z=-D/2;z<D/2;z++){
        const h = Math.floor((noise.noise2D(x*noiseScale, z*noiseScale)+1)/2 * (H-1)) + 1;
        for(let y=0;y<h;y++){
          const depth = h - y;
          let mats;
          if(depth===1) mats = grassMats;
          else if(depth<=4) mats = dirtMats;
          else mats = stoneMats;
          addBlock(x,y,z,mats);
        }
      }
    }

    // Interaction
    const ray = new THREE.Raycaster();
    document.addEventListener('mousedown', e=>{
      ray.setFromCamera({x:0,y:0}, camera);
      const hit = ray.intersectObjects(Object.values(blocks))[0];
      if(hit){
        const pos = hit.object.position.clone().subScalar(0.5);
        const n = hit.face.normal;
        const [x,y,z]=[pos.x,pos.y,pos.z];
        if(e.button===0) { scene.remove(blocks[key(x,y,z)]); delete blocks[key(x,y,z)]; }
        if(e.button===2) addBlock(x+n.x,y+n.y,z+n.z);
      }
    });
    document.addEventListener('contextmenu', e=>e.preventDefault());

    // Movement & jumping
    const velocity=new THREE.Vector3(), dir=new THREE.Vector3();
    const move={fw:false,back:false,left:false,right:false}; let canJump=false;
    const walkAccel=150, jumpSpeed=250, gravity=400;
    const km={KeyW:'fw',KeyS:'back',KeyA:'left',KeyD:'right'};
    document.addEventListener('keydown', e=>{
      if(e.code in km) move[km[e.code]] = true;
      if(e.code==='Space' && canJump){ velocity.y = jumpSpeed; canJump=false; }
    });
    document.addEventListener('keyup', e=>{ if(e.code in km) move[km[e.code]] = false; });

    // Pickaxe
    const pick = new THREE.Group();
    const handle = new THREE.Mesh(new THREE.BoxBufferGeometry(0.1,1,0.1), new THREE.MeshLambertMaterial({color:0x8B4513}));
    handle.position.set(0,-0.5,0); pick.add(handle);
    const head = new THREE.Mesh(new THREE.BoxBufferGeometry(0.6,0.1,0.1), new THREE.MeshLambertMaterial({color:0xcccccc}));
    head.position.set(0,-1,0); head.rotateZ(Math.PI/2); pick.add(head);
    scene.add(pick);

    // Other players
    const otherPlayers = {};
    const spriteMap = new THREE.TextureLoader().load('grant_scary.png');
    function getOrCreateSprite(id){
      if(!otherPlayers[id]){
        const mat = new THREE.SpriteMaterial({ map: spriteMap });
        const s = new THREE.Sprite(mat);
        scene.add(s);
        otherPlayers[id] = s;
      }
      return otherPlayers[id];
    }

    // Broadcast position
    setInterval(()=> broadcast({ type:'pos', x:camera.position.x, y:camera.position.y, z:camera.position.z }), 50);

    // Animate
    const clock = new THREE.Clock();
    camera.position.set(0, H+2, 0);
    function animate(){
      const dt = clock.getDelta();
      requestAnimationFrame(animate);
      if(controls.isLocked){
        velocity.y -= gravity * dt;
        dir.z = (move.fw?1:0) - (move.back?1:0);
        dir.x = (move.right?1:0) - (move.left?1:0);
        dir.normalize();
        if(move.fw||move.back) velocity.z -= dir.z * walkAccel * dt;
        if(move.left||move.right) velocity.x -= dir.x * walkAccel * dt;
        controls.moveRight(-velocity.x * dt);
        controls.moveForward(-velocity.z * dt);
        camera.position.y += velocity.y * dt;
        if(camera.position.y < H+2){ velocity.y=0; camera.position.y=H+2; canJump=true; }
      }
      pick.position.copy(camera.position); pick.quaternion.copy(camera.quaternion);
      pick.translateX(0.5); pick.translateY(-0.5); pick.translateZ(-1);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight);
    });
  </script>
</body>
</html>
