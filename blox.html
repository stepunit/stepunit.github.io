<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js P2P Minecraft Clone</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #instructions, #peer-info {
      position: absolute; width: 100%; text-align: center;
      color: #ffffff; font-family: Arial; user-select: none;
    }
    #instructions { top: 50%; font-size: 24px; }
    #peer-info { top: 10px; font-size: 14px; }
    #connect { position: absolute; top: 40px; left: 50%; transform: translateX(-50%); }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
      "three/examples/jsm/controls/PointerLockControls.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/PointerLockControls.js"
    }
  }
  </script>
  <script src="https://unpkg.com/peerjs@1.3.2/dist/peerjs.min.js"></script>
</head>
<body>
  <div id="instructions">Click to play</div>
  <div id="peer-info"></div>
  <input id="connect" placeholder="Enter peer ID and press Enter" />

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

    // P2P Setup via PeerJS
    const peer = new Peer();
    const connections = {};
    const playerNames = {};

    peer.on('open', id => {
      document.getElementById('peer-info').textContent = `Your Peer ID: ${id}`;
    });

    document.getElementById('connect').addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const remoteId = e.target.value.trim();
        if (!connections[remoteId]) {
          const conn = peer.connect(remoteId);
          setupConnection(conn);
        }
        e.target.value = '';
      }
    });

    peer.on('connection', conn => {
      setupConnection(conn);
    });

    function setupConnection(conn) {
      connections[conn.peer] = conn;
      conn.on('data', data => {
        if (data.type === 'join') {
          playerNames[conn.peer] = data.name;
        } else if (data.type === 'pos') {
          const sprite = getOrCreateSprite(conn.peer);
          sprite.position.set(data.x, data.y, data.z);
        }
      });
      // send own name
      conn.on('open', () => conn.send({ type: 'join', name: playerName }));
    }

    function broadcast(data) {
      Object.values(connections).forEach(conn => conn.send(data));
    }

    // Random name generator
    const adjectives = ['Brave','Cunning','Swift','Ancient','Mighty','Silent','Fierce','Gentle'];
    const nouns = ['Lion','Wolf','Eagle','Dragon','Fox','Tiger','Bear','Hawk'];
    function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    const playerName = rand(adjectives) + rand(nouns) + Math.floor(Math.random()*1000);

    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new PointerLockControls(camera, document.body);
    const instructions = document.getElementById('instructions');
    instructions.addEventListener('click', () => controls.lock());
    controls.addEventListener('lock', () => instructions.style.display='none');
    controls.addEventListener('unlock', () => instructions.style.display='');

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 0.6);
    light.position.set(100,100,50);
    scene.add(light);

    // Blocks
    const W=32, D=32, H=8;
    const blocks = {}, geoms = {};
    const blockMats = Array(6).fill().map((_,i) => new THREE.MeshLambertMaterial({ color: i===0 ? 0x00ff00 : 0x964B00 }));
    const key = (x,y,z)=>`${x},${y},${z}`;
    function addBlock(x,y,z) {
      const gk='1x1x1'; if(!geoms[gk]) geoms[gk]=new THREE.BoxBufferGeometry(1,1,1);
      const m=new THREE.Mesh(geoms[gk], blockMats); m.position.set(x+0.5,y+0.5,z+0.5);
      scene.add(m); blocks[key(x,y,z)] = m;
    }
    function removeBlock(x,y,z){ const k=key(x,y,z); if(blocks[k]){ scene.remove(blocks[k]); delete blocks[k]; }}
    for(let x=-W/2;x<W/2;x++) for(let z=-D/2;z<D/2;z++) for(let y=0;y<H;y++) addBlock(x,y,z);

    const ray = new THREE.Raycaster();
    document.addEventListener('mousedown', e => {
      ray.setFromCamera({x:0,y:0}, camera);
      const hits = ray.intersectObjects(Object.values(blocks));
      if(hits.length) {
        const h=hits[0], pos=h.object.position.clone().subScalar(0.5), n=h.face.normal;
        const [x,y,z]=[pos.x,pos.y,pos.z];
        if(e.button===0) removeBlock(x,y,z);
        if(e.button===2) addBlock(x+n.x,y+n.y,z+n.z);
      }
    });
    document.addEventListener('contextmenu', e=>e.preventDefault());

    // Movement & jumping
    const velocity=new THREE.Vector3(), dir=new THREE.Vector3();
    const move={fw:false,back:false,left:false,right:false}; let canJump=false;
    const walkAccel=600, jumpSpeed=250, gravity=400;
    const km={KeyW:'fw',KeyS:'back',KeyA:'left',KeyD:'right'};
    document.addEventListener('keydown', e=>{
      if(e.code in km) move[km[e.code]] = true;
      if(e.code==='Space' && canJump){ velocity.y = jumpSpeed; canJump=false; }
    });
    document.addEventListener('keyup', e=>{ if(e.code in km) move[km[e.code]] = false; });

    // Pickaxe
    const pick=new THREE.Group();
    const h=new THREE.Mesh(new THREE.BoxBufferGeometry(0.1,1,0.1), new THREE.MeshLambertMaterial({color:0x8B4513})); h.position.set(0,-0.5,0); pick.add(h);
    const hd=new THREE.Mesh(new THREE.BoxBufferGeometry(0.6,0.1,0.1), new THREE.MeshLambertMaterial({color:0xcccccc})); hd.position.set(0,-1,0); hd.rotateZ(Math.PI/2); pick.add(hd);
    scene.add(pick);

    // Other players
    const otherPlayers = {};
    const spriteMap = new THREE.TextureLoader().load('grant_scary.png');
    function getOrCreateSprite(id) {
      if(!otherPlayers[id]){
        const mat = new THREE.SpriteMaterial({ map: spriteMap });
        const s = new THREE.Sprite(mat);
        scene.add(s);
        otherPlayers[id] = s;
      }
      return otherPlayers[id];
    }

    // Send position periodically
    setInterval(() => {
      const p = { type:'pos', x:camera.position.x, y:camera.position.y, z:camera.position.z };
      broadcast(p);
    }, 50);

    // Animation
    const clock = new THREE.Clock();
    camera.position.set(0, H+2, 0);
    function animate() {
      const dt = clock.getDelta(); requestAnimationFrame(animate);
      if(controls.isLocked) {
        velocity.y -= gravity * dt;
        dir.z = (move.fw?1:0) - (move.back?1:0);
        dir.x = (move.right?1:0) - (move.left?1:0);
        dir.normalize();
        if(move.fw||move.back) velocity.z -= dir.z * walkAccel * dt;
        if(move.left||move.right) velocity.x -= dir.x * walkAccel * dt;
        controls.moveRight(-velocity.x * dt);
        controls.moveForward(-velocity.z * dt);
        camera.position.y += velocity.y * dt;
        if(camera.position.y < H+2){ velocity.y=0; camera.position.y=H+2; canJump=true; }
      }
      pick.position.copy(camera.position); pick.quaternion.copy(camera.quaternion);
      pick.translateX(0.5); pick.translateY(-0.5); pick.translateZ(-1);
      renderer.render(scene,camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight);
    });
  </script>
</body>
</html>
