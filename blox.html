<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js P2P Minecraft Clone with Chat</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #instructions, #peer-info {
      position: absolute; width: 100%; text-align: center;
      color: #ffffff; font-family: Arial; user-select: none;
    }
    #instructions { top: 50%; font-size: 24px; }
    #peer-info { top: 10px; font-size: 14px; }
    #connect { position: absolute; top: 40px; left: 50%; transform: translateX(-50%); }
    /* Chat UI */
    #chat-container {
      position: absolute; bottom: 0; left: 0;
      width: 300px; max-height: 40%;
      display: flex; flex-direction: column;
      background: rgba(0,0,0,0.5); padding: 5px;
      font-family: Arial; color: #fff;
    }
    #chat-log {
      flex: 1; overflow-y: auto;
      margin-bottom: 5px;
    }
    #chat-log div { margin: 2px 0; }
    #chat-input {
      width: 100%; box-sizing: border-box;
      padding: 5px; border: none;
      outline: none;
      font-size: 14px;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
      "three/examples/jsm/controls/PointerLockControls.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/PointerLockControls.js"
    }
  }
  </script>
  <script src="https://unpkg.com/peerjs@1.3.2/dist/peerjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
</head>
<body>
  <div id="instructions">Click to play</div>
  <div id="peer-info"></div>
  <input id="connect" placeholder="Enter peer ID and press Enter" />
  <div id="chat-container">
    <div id="chat-log"></div>
    <input id="chat-input" placeholder="Type a message and press Enter" />
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

    // === P2P Setup ===
    const peer = new Peer();
    const connections = {}, playerNames = {};
    let myId;
    peer.on('open', id => {
      myId = id;
      document.getElementById('peer-info').textContent = `Your Peer ID: ${id}`;
    });
    document.getElementById('connect').addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const remote = e.target.value.trim();
        if (remote && !connections[remote]) setupConnection(peer.connect(remote));
        e.target.value = '';
      }
    });
    peer.on('connection', setupConnection);

    function setupConnection(conn) {
      connections[conn.peer] = conn;
      conn.on('data', data => handleData(conn.peer, data));
      conn.on('open', () => {
        conn.send({ type: 'join', name: playerName });
        conn.send({ type: 'pos', x: camera.position.x, y: camera.position.y, z: camera.position.z });
      });
    }

    function broadcast(msg) {
      Object.values(connections).forEach(c => c.send(msg));
    }

    function handleData(peerId, data) {
      if (data.type === 'join') {
        playerNames[peerId] = data.name;
        appendChat(`${data.name} joined.`);
      }
      if (data.type === 'chat') {
        appendChat(`${data.name}: ${data.text}`);
      }
      if (data.type === 'pos') {
        updateOther(peerId, data);
      }
    }

    // === Chat UI ===
    const chatLog = document.getElementById('chat-log');
    const chatInput = document.getElementById('chat-input');
    function appendChat(msg) {
      const div = document.createElement('div');
      div.textContent = msg;
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter' && chatInput.value.trim()) {
        const text = chatInput.value.trim();
        appendChat(`You: ${text}`);
        broadcast({ type: 'chat', name: playerName, text });
        chatInput.value = '';
      }
    });

    // === Player Name ===
    const adjectives = ['Brave','Cunning','Swift','Ancient','Mighty','Silent','Fierce','Gentle'];
    const nouns = ['Lion','Wolf','Eagle','Dragon','Fox','Tiger','Bear','Hawk'];
    function rand(arr) { return arr[Math.floor(Math.random()*arr.length)]; }
    const playerName = rand(adjectives) + rand(nouns) + Math.floor(Math.random()*1000);

    // === Three.js Setup ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Controls & Lighting
    const controls = new PointerLockControls(camera, document.body);
    const instr = document.getElementById('instructions');
    instr.addEventListener('click', () => controls.lock());
    controls.addEventListener('lock', () => instr.style.display = 'none');
    controls.addEventListener('unlock', () => instr.style.display = '');
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const sun = new THREE.DirectionalLight(0xffffff, 0.6);
    sun.position.set(100, 100, 50);
    scene.add(sun);

    // === Terrain Generation ===
    const grassFaces = [1,1,0,1,1,1];
    const grassMats = grassFaces.map(f => new THREE.MeshLambertMaterial({ color: f ? 0x964B00 : 0x00ff00 }));
    const dirtMats = Array(6).fill().map(() => new THREE.MeshLambertMaterial({ color: 0x964B00 }));
    const stoneMats = Array(6).fill().map(() => new THREE.MeshLambertMaterial({ color: 0x888888 }));

    const simplex = new SimplexNoise();
    const noiseScale = 0.1;
    const W = 32, D = 32, H = 16;
    const blocks = {};
    let boxGeom;
    function addBlock(x, y, z, mats) {
      if (!boxGeom) boxGeom = new THREE.BoxBufferGeometry(1,1,1);
      const m = new THREE.Mesh(boxGeom, mats);
      m.position.set(x+0.5, y+0.5, z+0.5);
      scene.add(m);
      blocks[`${x},${y},${z}`] = m;
    }
    for (let x = -W/2; x < W/2; x++) {
      for (let z = -D/2; z < D/2; z++) {
        const h = Math.floor((simplex.noise2D(x*noiseScale, z*noiseScale)+1)/2 * (H-1)) + 1;
        for (let y = 0; y < h; y++) {
          const depth = h - y;
          const mats = depth === 1 ? grassMats : depth <= 4 ? dirtMats : stoneMats;
          addBlock(x, y, z, mats);
        }
      }
    }

    // === Collision & Movement ===
    function colliding(px, pz, py) {
      const foot = Math.floor(py - 1.6 + 0.1);
      const head = Math.floor(py - 0.1);
      const keyFoot = `${Math.floor(px)},${foot},${Math.floor(pz)}`;
      const keyHead = `${Math.floor(px)},${head},${Math.floor(pz)}`;
      return blocks[keyFoot] || blocks[keyHead];
    }

    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const move = { fw:false, back:false, left:false, right:false };
    let canJump = false;
    const walkAccel = 150, jumpSpeed = 25, gravity = 100, friction = 15;
    const km = { KeyW:'fw', KeyS:'back', KeyA:'left', KeyD:'right' };
    document.addEventListener('keydown', e => {
      if (e.code in km) move[km[e.code]] = true;
      if (e.code === 'Space' && canJump) { velocity.y = jumpSpeed; canJump = false; }
    });
    document.addEventListener('keyup', e => { if (e.code in km) move[km[e.code]] = false; });

    document.addEventListener('mousedown', e => {
      const ray = new THREE.Raycaster();
      ray.setFromCamera({ x:0, y:0 }, camera);
      const hit = ray.intersectObjects(Object.values(blocks))[0];
      if (hit) {
        const pos = hit.object.position.clone().subScalar(0.5);
        const n = hit.face.normal;
        const bx = Math.floor(pos.x), by = Math.floor(pos.y), bz = Math.floor(pos.z);
        if (e.button === 0) {
          delete blocks[`${bx},${by},${bz}`];
          scene.remove(hit.object);
        } else if (e.button === 2) {
          const key = `${bx+n.x},${by+n.y},${bz+n.z}`;
          if (!blocks[key]) addBlock(bx+n.x, by+n.y, bz+n.z, dirtMats);
        }
      }
    });
    document.addEventListener('contextmenu', e => e.preventDefault());

    // === Pickaxe ===
    const pick = new THREE.Group();
    const handleMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(0.1,1,0.1), new THREE.MeshLambertMaterial({ color:0x8B4513 }));
    handleMesh.position.set(0,-0.5,0); pick.add(handleMesh);
    const headMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(0.6,0.1,0.1), new THREE.MeshLambertMaterial({ color:0xcccccc }));
    headMesh.position.set(0,-1,0); headMesh.rotateZ(Math.PI/2); pick.add(headMesh);
    scene.add(pick);

    // === Other Players ===
    const others = {};
    const spriteTex = new THREE.TextureLoader().load('grant_scary.png');
    function getOther(id) {
      if (!others[id]) {
        const mat = new THREE.SpriteMaterial({ map: spriteTex });
        const s = new THREE.Sprite(mat);
        scene.add(s);
        others[id] = s;
      }
      return others[id];
    }
    function updateOther(id, data) {
      getOther(id).position.set(data.x, data.y, data.z);
    }
    setInterval(() => {
      broadcast({ type:'pos', x:camera.position.x, y:camera.position.y, z:camera.position.z });
    }, 100);

    // === Animation Loop ===
    const clock = new THREE.Clock();
    camera.position.set(0, (Math.max(...Object.keys(blocks).map(k => k.split(',').map(Number)[1])) || 0) + 1.6, 0);
    function animate() {
      const dt = clock.getDelta();
      requestAnimationFrame(animate);
      if (controls.isLocked) {
        velocity.y -= gravity * dt;
        direction.z = (move.fw ? 1 : 0) - (move.back ? 1 : 0);
        direction.x = (move.right ? 1 : 0) - (move.left ? 1 : 0);
        direction.normalize();
        if (move.fw || move.back) velocity.z -= direction.z * walkAccel * dt;
        if (move.left || move.right) velocity.x -= direction.x * walkAccel * dt;
        velocity.x -= velocity.x * friction * dt;
        velocity.z -= velocity.z * friction * dt;
        // X movement
        const oldX = camera.position.x;
        controls.moveRight(-velocity.x * dt);
        if (colliding(camera.position.x, camera.position.z, camera.position.y)) camera.position.x = oldX;
        // Z movement
        const oldZ = camera.position.z;
        controls.moveForward(-velocity.z * dt);
        if (colliding(camera.position.x, camera.position.z, camera.position.y)) camera.position.z = oldZ;
        // Y movement
        camera.position.y += velocity.y * dt;
        const eye = 1.6;
        const footKey = `${Math.floor(camera.position.x)},${Math.floor(camera.position.y - eye)},${Math.floor(camera.position.z)}`;
        if (blocks[footKey]) { camera.position.y = Math.floor(camera.position.y - eye) + eye; velocity.y = 0; canJump = true; }
      }
      // pickaxe follows camera
      pick.position.copy(camera.position);
      pick.quaternion.copy(camera.quaternion);
      pick.translateX(0.5);
      pick.translateY(-0.5);
      pick.translateZ(-1);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
