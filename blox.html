<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Minecraft Clone</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #instructions {
      position: absolute; top: 50%; width: 100%; text-align: center;
      color: #ffffff; font-family: Arial; font-size: 24px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="instructions">Click to play</div>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
    import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/PointerLockControls.js';

    // Scene, camera, renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new PointerLockControls(camera, document.body);
    const instructions = document.getElementById('instructions');
    instructions.addEventListener('click', () => {
      controls.lock();
    });
    controls.addEventListener('lock', () => { instructions.style.display = 'none'; });
    controls.addEventListener('unlock', () => { instructions.style.display = ''; });

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xffffff, 0.6);
    sun.position.set(100, 100, 50);
    scene.add(sun);

    // Materials (grass top, dirt bottom and sides)
    const materials = [
      new THREE.MeshLambertMaterial({ color: 0x00ff00 }), // top
      new THREE.MeshLambertMaterial({ color: 0x964B00 }), // bottom
      new THREE.MeshLambertMaterial({ color: 0x964B00 }), // north
      new THREE.MeshLambertMaterial({ color: 0x964B00 }), // south
      new THREE.MeshLambertMaterial({ color: 0x964B00 }), // east
      new THREE.MeshLambertMaterial({ color: 0x964B00 })  // west
    ];

    // World parameters
    const worldWidth = 32;
    const worldDepth = 32;
    const worldHeight = 8;
    const blocks = {};
    const geometries = {};

    function key(x, y, z) {
      return `${x},${y},${z}`;
    }

    function addBlock(x, y, z) {
      const geomKey = '1x1x1';
      if (!geometries[geomKey]) {
        geometries[geomKey] = new THREE.BoxBufferGeometry(1, 1, 1);
      }
      const mesh = new THREE.Mesh(geometries[geomKey], materials);
      mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
      scene.add(mesh);
      blocks[key(x, y, z)] = mesh;
    }

    function removeBlock(x, y, z) {
      const k = key(x, y, z);
      if (blocks[k]) {
        scene.remove(blocks[k]);
        delete blocks[k];
      }
    }

    // Initialize flat world
    for (let x = -worldWidth / 2; x < worldWidth / 2; x++) {
      for (let z = -worldDepth / 2; z < worldDepth / 2; z++) {
        for (let y = 0; y < worldHeight; y++) {
          addBlock(x, y, z);
        }
      }
    }

    // Raycaster for block interactions
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function interact(event) {
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const intersects = raycaster.intersectObjects(Object.values(blocks));
      if (intersects.length > 0) {
        const intersect = intersects[0];
        const pos = intersect.object.position.clone().subScalar(0.5);
        const normal = intersect.face.normal;
        const x = pos.x;
        const y = pos.y;
        const z = pos.z;
        if (event.button === 0) {
          removeBlock(x, y, z);
        } else if (event.button === 2) {
          addBlock(x + normal.x, y + normal.y, z + normal.z);
        }
      }
    }

    document.addEventListener('mousedown', interact);
    document.addEventListener('contextmenu', event => event.preventDefault());

    // Movement
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const move = { forward: false, back: false, left: false, right: false };

    document.addEventListener('keydown', event => {
      switch (event.code) {
        case 'KeyW': move.forward = true; break;
        case 'KeyS': move.back = true;    break;
        case 'KeyA': move.left = true;    break;
        case 'KeyD': move.right = true;   break;
      }
    });
    document.addEventListener('keyup', event => {
      switch (event.code) {
        case 'KeyW': move.forward = false; break;
        case 'KeyS': move.back = false;    break;
        case 'KeyA': move.left = false;    break;
        case 'KeyD': move.right = false;   break;
      }
    });

    // Animation loop
    camera.position.set(0, worldHeight + 2, 0);
    function animate() {
      requestAnimationFrame(animate);
      if (controls.isLocked) {
        // Decay velocity
        velocity.x -= velocity.x * 10.0 * 0.016;
        velocity.z -= velocity.z * 10.0 * 0.016;
        // Determine direction
        direction.z = (move.forward ? 1 : 0) - (move.back ? 1 : 0);
        direction.x = (move.right ? 1 : 0) - (move.left ? 1 : 0);
        direction.normalize();
        // Apply acceleration
        if (move.forward || move.back) velocity.z -= direction.z * 400.0 * 0.016;
        if (move.left || move.right)    velocity.x -= direction.x * 400.0 * 0.016;
        controls.moveRight(-velocity.x * 0.016);
        controls.moveForward(-velocity.z * 0.016);
      }
      renderer.render(scene, camera);
    }
    animate();

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
